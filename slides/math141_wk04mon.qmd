---
pagetitle: "Statistical Modeling"
editor: source
format: 
  revealjs:
    chalkboard: true
    incremental: true
    theme: [default, custom.scss]
    height: 900
    width: 1600
    slide-number: c
    auto-stretch: false
    callout-appearance: simple
    pdf-max-pages-per-slide: 2
    menu: 
      side: right
      numbers: true
execute:
  echo: true
  warning: false
  message: false
---

```{r}
#| include: false
#| warning: false
#| message: false

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.retina = 3, fig.align = 'center')
library(knitr)
library(tidyverse)
```

::::: columns
::: {.column .center width="50%"}
![](img/DAW.jpeg){width="90%"}
:::

::: {.column .center width="50%"}
<br>

[Simple Linear Regression I]{.custom-title}

<br> <br> <br> <br> <br> 

[Grayson White]{.custom-subtitle}

[Math 141 <br> Week 4 \| Fall 2025]{.custom-subtitle}
:::
:::::

------------------------------------------------------------------------

## Goals for Today

-   Discuss the ideas of statistical modeling
-   Learn two new summary statistics
-   Introduce simple linear regression

## Typical Analysis Goals

**Descriptive**: Want to estimate quantities related to the population.

→ How many trees are in Alaska?

<br>

**Predictive**: Want to predict the value of a variable.

→ Can I use remotely sensed data to predict forest types in Alaska?

<br>

**Causal**: Want to determine if changes in a variable cause changes in another variable.

→ Are insects causing the increased mortality rates for pinyon-juniper woodlands?

<br><br>

::: fragment
We will focus mainly on **descriptive modeling** in this course. If you want to learn more about **predictive modeling**, take Math 243: Statistical Learning, and if you want to learn more about **causality**, take Math 394: Causal Inference.
:::

------------------------------------------------------------------------

## Form of the Model

<br><br><br>

$$
y = f(x) + \epsilon
$$

<br><br><br>

**Goal:**

-   Determine a reasonable form for $f()$. (Ex: Line, curve, ...)

-   Estimate $f()$ with $\hat{f}()$ using the data.

-   Generate predicted values: $\hat y = \hat{f}(x)$.

------------------------------------------------------------------------

### Simple Linear Regression Model

Consider this model when:

-   Response variable $(y)$: quantitative

-   Explanatory variable $(x)$: quantitative

    -   Have only ONE explanatory variable.

-   AND, $f()$ can be approximated by a line.

------------------------------------------------------------------------

### Example: [The Ultimate Halloween Candy Power Ranking](https://fivethirtyeight.com/videos/the-ultimate-halloween-candy-power-ranking/)

> "The social contract of Halloween is simple: Provide adequate treats to costumed masses, or be prepared for late-night tricks from those dissatisfied with your offer. To help you avoid that type of vengeance, and to help you make good decisions at the supermarket this weekend, we wanted to figure out what Halloween candy people most prefer. So we devised an experiment: Pit dozens of fun-sized candy varietals against one another, and let the wisdom of the crowd decide which one was best." -- Walt Hickey

> "While we don't know who exactly voted, we do know this: 8,371 different IP addresses voted on about 269,000 randomly generated matchups. So, not a scientific survey or anything, but a good sample of what candy people like."

------------------------------------------------------------------------

### Example: [The Ultimate Halloween Candy Power Ranking](https://fivethirtyeight.com/videos/the-ultimate-halloween-candy-power-ranking/)

```{r, echo = FALSE, out.width='80%'}
knitr::include_graphics("img/candy_ex.png")
```

------------------------------------------------------------------------

### Example: [The Ultimate Halloween Candy Power Ranking](https://fivethirtyeight.com/videos/the-ultimate-halloween-candy-power-ranking/)

```{r}
candy <- read_csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/candy-power-ranking/candy-data.csv") %>%
  mutate(pricepercent = pricepercent*100)

glimpse(candy)

```

------------------------------------------------------------------------

### Example: [The Ultimate Halloween Candy Power Ranking](https://fivethirtyeight.com/videos/the-ultimate-halloween-candy-power-ranking/)

::::: columns
::: column
-   Linear trend?

-   Direction of trend?
:::

::: column
```{r}
#| echo: false
ggplot(data = candy, 
       mapping = aes(x = pricepercent,
                     y = winpercent)) +
  geom_point(alpha = 0.6, size = 4, 
             color = "chocolate4")
```
:::
:::::

------------------------------------------------------------------------

### Example: [The Ultimate Halloween Candy Power Ranking](https://fivethirtyeight.com/videos/the-ultimate-halloween-candy-power-ranking/)

::::: columns
::: column
-   A simple linear regression model would be suitable for these data.

-   But first, let's describe more plots!
:::

::: column
```{r}
#| echo: false
ggplot(data = candy, 
       mapping = aes(x = pricepercent,
                     y = winpercent)) +
  geom_point(alpha = 0.6, size = 4, 
             color = "chocolate4") +
  geom_smooth(method = "lm", se = FALSE,
              color = "deeppink2")
```
:::
:::::

------------------------------------------------------------------------

```{r}
#| echo: false

set.seed(4119)
x <- runif(50, 0, 10)
y1 <- 3 + 1*x + rnorm(50, 0 , 3)
y2 <- runif(50, 0, 10)
y3 <- 1 - .5*x + rnorm(50, 0, 1)
y4 <- 3 + -40*x +  4*x^2 + rnorm(50, 0, 20)
dat <- data_frame(x, y1, y2, y3, y4)  

library(cowplot)
# Create scatterplots and place in a grid
p1 <- ggplot(dat, aes(x, y1)) + geom_point()
p2 <- ggplot(dat, aes(x, y2)) + geom_point()
p3 <- ggplot(dat, aes(x, y3)) + geom_point()
p4 <- ggplot(dat, aes(x, y4)) + geom_point()
plot_grid(p1, p2, p3, p4, ncol=2, labels = c("A", "B", "C", "D"))

```

-   Need a summary statistics that quantifies the strength and relationship of the linear trend!

------------------------------------------------------------------------

## (Sample) Correlation Coefficient

::::{.columns}

:::{.column width=45%}

-   Measures the **strength** and **direction** of **linear** relationship between two quantitative variables

-   Symbol: $r$

-   Always between -1 and 1

-   Sign indicates the direction of the relationship

-   Magnitude indicates the strength of the linear relationship

::: fragment
```{r}
candy %>%
  summarize(cor = cor(pricepercent, winpercent))
```
:::


:::

:::{.column width=10%}

:::

:::{.column width=45%}

:::{.fragment}

$r$ is calculated using the sample means ($\bar{x}$, $\bar{y}$) and standard deviations ($s_x$, $s_y$) of the variables $x$ and $y$:

:::

:::{.fragment}
  
$$r = \frac{1}{s_x s_y} \cdot \frac{1}{n-1} \sum_{i =1}^n (x_i - \bar{x} )  (y_i - \bar{y} ) $$
:::

:::

::::

------------------------------------------------------------------------


## Sidenote: (Sample) Covariance

**Sample Correlation Coefficient**: 
$$
r = \frac{1}{s_x s_y} \cdot \frac{1}{n-1} \sum_{i =1}^n (x_i - \bar{x} )  (y_i - \bar{y} ) 
$$

:::{.fragment}

**Sample Covariance**:

$$
cov(x, y) = r \times s_x s_y = \frac{1}{n-1} \sum_{i =1}^n (x_i - \bar{x} )  (y_i - \bar{y} ) 
$$
:::

:::{.fragment}

The sample correlation coefficient is a **standardized sample covariance**, which is what causes it to only take values from -1 to 1. The sample covariance can take any real value. 

:::

------------------------------------------------------------------------

:::::: columns
::: {.column .center}
```{r, echo = FALSE, fig.align='center'}

plot_grid(p1, p2, p3, p4, ncol=2, labels = c("A", "B", "C", "D"))

```
:::

:::: column
Any guesses on the correlations for A, B, C, or D?

::: fragment
```{r}
dat %>%
  summarize(A = cor(x, y1), B = cor(x, y2),
            C = cor(x, y3), D = cor(x, y4))
```
:::
::::
::::::

------------------------------------------------------------------------

## New Example

```{r, echo = FALSE}
# Load new dataset
dat2 <- read_csv("data/datasaurus.csv") %>%
  filter(dataset != "slant_up")
```

::::: columns
::: column
```{r}
# Correlation coefficients
dat2 %>%
  group_by(dataset) %>%
  summarize(cor = cor(x, y))
```
:::

::: column
-   Conclude that $x$ and $y$ have the same relationship across these different datasets because the correlation is the same?
:::
:::::

------------------------------------------------------------------------

#### Always graph the data when exploring relationships!

```{r}
#| echo: false
ggplot(data = dat2, mapping = aes(x = x, y = y)) +
  geom_point() +
  facet_wrap(~ dataset, ncol = 4)
```

# Returning to the Simple Linear Regression model...

------------------------------------------------------------------------

### Simple Linear Regression

::::: columns
::: column
Let's return to the Candy Example.

-   A line is a reasonable model form.

-   Where should the line be?

    -   Slope? Intercept?
:::

::: column
```{r}
#| echo: false
ggplot(data = candy, 
       mapping = aes(x = pricepercent,
                     y = winpercent)) +
  geom_point(alpha = 0.6, size = 4, 
             color = "chocolate4") +
  geom_smooth(method = "lm", se = FALSE,
              color = "deeppink2") + 
  geom_smooth(method = "lm", se = FALSE, data = candy[1:30,], color = "purple") +
  geom_smooth(method = "lm", se = FALSE, data = candy[40:80,], color = "orange") 
```
:::
:::::

------------------------------------------------------------------------

### Form of the SLR Model

$$ 
\begin{align}
y &= f(x) + \epsilon \\
y &= \beta_o + \beta_1 x + \epsilon
\end{align}
$$

-   Need to determine the best **estimates** of $\beta_o$ and $\beta_1$.

------------------------------------------------------------------------

#### Distinguishing between the **population** and the **sample**

::::: columns
::: column
$$ 
y = \beta_o + \beta_1 x + \epsilon
$$

-   Parameters:
    -   Based on the **population**
    -   Unknown then if don't have data on the whole population
    -   EX: $\beta_o$ and $\beta_1$
:::

::: column
$$
\hat{y} = \hat{ \beta}_o + \hat{\beta}_1 x
$$

-   Statistics:
    -   Based on the **sample** data
    -   Known
    -   Usually estimate a population parameter
    -   EX: $\hat{\beta}_o$ and $\hat{\beta}_1$
:::
:::::

------------------------------------------------------------------------

### Method of Least Squares

Need two key definitions:

-   **Fitted value**: The *estimated* value of the $i$-th case

::: fragment
$$
\hat{y}_i = \hat{\beta}_o + \hat{\beta}_1 x_i
$$
:::

-   **Residuals**: The *observed* error term for the $i$-th case

::: fragment
$$
e_i = y_i - \hat{y}_i
$$

**Goal**: Pick values for $\hat{\beta}_o$ and $\hat{\beta}_1$ so that the residuals are small!
:::

------------------------------------------------------------------------

### Method of Least Squares

:::::: columns
:::: column
-   Want residuals to be small.

-   Minimize a function of the residuals.

-   Minimize:

::: fragment
$$
\sum_{i = 1}^n e^2_i
$$
:::
::::

::: column
```{r, echo=FALSE, eval = TRUE}
ggplot(data = candy, 
       mapping = aes(x = pricepercent,
                     y = winpercent)) +
  geom_point(alpha = 0.6, size = 4, 
             color = "chocolate4") +
  stat_smooth(method = "lm", se = FALSE,
              color = "deeppink2") +
  annotate("segment", x = candy$pricepercent, 
           xend = candy$pricepercent, 
           y = candy$winpercent, yend = 42 + .178*candy$pricepercent, 
           color = "darkblue", arrow = arrow(length = unit(0.03, "npc"))) + 
  geom_point()
  
```
:::
::::::

------------------------------------------------------------------------

### Method of Least Squares

After minimizing the sum of squared residuals, you get the following equations:

Get the following equations:

$$ 
\begin{align}
\hat{\beta}_1 &= \frac{ \sum_{i = 1}^n (x_i - \bar{x}) (y_i - \bar{y})}{ \sum_{i = 1}^n (x_i - \bar{x})^2} \\
\hat{\beta}_o &= \bar{y} - \hat{\beta}_1 \bar{x}
\end{align}
$$ where

$$
\begin{align}
\bar{y} = \frac{1}{n} \sum_{i = 1}^n y_i \quad \mbox{and} \quad \bar{x} = \frac{1}{n} \sum_{i = 1}^n x_i
\end{align}
$$

------------------------------------------------------------------------

### Method of Least Squares

Then we can estimate the whole function with:

$$
\hat{y} = \hat{\beta}_o + \hat{\beta}_1 x
$$

Called the **least squares line** or the **line of best fit**.

------------------------------------------------------------------------

### Method of Least Squares

`ggplot2` will compute the line and add it to your plot using `geom_smooth(method = "lm")`

```{r}
#| output-location: column
ggplot(data = candy, 
       mapping = aes(x = pricepercent,
                     y = winpercent)) +
  geom_point(alpha = 0.6, size = 4, 
             color = "chocolate4") +
  geom_smooth(method = "lm", se = FALSE,
              color = "deeppink2")
```

But what are the **exact** values of $\hat{\beta}_o$ and $\hat{\beta}_1$?

------------------------------------------------------------------------


## Next time: more simple linear regression

-   We'll use `R` to compute the least squares line and **exact** values of $\hat{\beta}_o$ and $\hat{\beta}_1$. 
-   We'll introduce the formal assumptions we must make when doing linear regression, and diagnostic plots to check these assumptions. 


